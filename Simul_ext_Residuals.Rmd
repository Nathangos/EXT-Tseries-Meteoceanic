---
title: "R Notebook"
output: html_notebook
---

```{r}
rm(list=ls())
set.seed(133)
par(mfrow=c(1,1))

#### Import des packages. #####
source("fonctions/fonctions_Pareto.R")
source("fonctions/fonctions.R")
require(dplyr)
require(ggplot2)
require(scales)
require(reshape2)
require(ggside)
require(FactoMineR)
require(extRemes)
require(fda)
require(parallel)
require(VineCopula)
require(grid)
require(gridExtra)
require(ggside)
### Function origins ####
F_names<-ls()
nb_CPU_hearts<-detectCores()-4


# Cluster opening --------------------------------------------------
CPU_hearts<-makeCluster(nb_CPU_hearts)
clusterExport(CPU_hearts,varlist=F_names)
```


```{r}
name_variable<-"Surcote"
link_data<-paste0("residuals/S_residuals.csv")
std_data<-TRUE
p_U<-rep(0.10,37)
p_L2<-0.05
NB_dim_ACP<-3
opt_Frech<-TRUE
M<-2000
n.dens<-2^(14)
```

```{r}
Data<-read.csv(file=link_data)[,2:38]
colnames(Data)<-c(1:37)
rownames(Data)<-c(1:nrow(Data))
dates_import<-read.csv("data_detrend_Winter/dates.csv")[,2]
d_POIXCT<-as.POSIXct(dates_import, format="%d/%m/%Y")
Nb_years<-diff(range(lubridate::year(d_POIXCT)))
NPY<-nrow(Data)/Nb_years

```

##2) Extreme value diagnostic
```{r}
L<-200
vect_k<-c(20:L)
L2<-apply(X = Data,MARGIN = 1,FUN = calcul_norm_L2)
Graphics_estimators_gamma(series = L2,vect_k = vect_k,
                             Title_graphic  = "Extreme of L2 before transformation")
```

As we see that the type of extreme is not convenient, we need to apply a marginal transformation. The latter uses as parameter a threshold $u_{t}$ defined at each time t.

```{r}
Time_analysed<-c(19)
AN_GPD<-Analyse_threshd_GPD(data = Data,fonction_threshd = p_U,n.dens = n.dens,name =name_variable,dates_taken=dates_import,j_show=Time_analysed)
vector_DIM<-c(1:ncol(Data))
```

## 3) Applying the marginal transformation
```{r}
result_P<-as.data.frame(t(sapply(vector_DIM,f_marginales_all_Pareto,data_to_tf = Data,p_u=p_U,n.dens=n.dens)))

K<-result_P$kernel_dens
PARETO<-result_P$obs
L_EVT<-list("gamma"=result_P$gamma,
            "scale"=result_P$scale,
            "threshold"=result_P$threshold,
            "p_u"=result_P$p_u)
vector_pareto<-do.call(cbind.data.frame,PARETO)

# Hypothèse Pareto pour la transformation ---------------------------------
Analyse_Pareto_per_time(data_Pareto = vector_pareto,name = name_variable,n.dens=n.dens)
```

## 5) Approach the angle of the transShaped time series
```{r}
if(opt_Frech==TRUE){
  Unif<-1-(as.matrix(vector_pareto))^(-1)
  vector_pareto<-(-1)*(log(Unif))^(-1)
  for(t in c(1:ncol(vector_pareto))){
    serie_frech_t<-vector_pareto[,t]
  }
}
vector_norm_L2<-apply(X= vector_pareto,MARGIN = 1,FUN =calcul_norm_L2)

rownames(vector_pareto)<-1:nrow(vector_pareto)
colnames(vector_pareto)<-c(1:ncol(vector_pareto))

v_threshd<-quantile(vector_norm_L2,1-p_L2)
Inds_Exts<-which(vector_norm_L2>v_threshd)
Vect_L2_exts<-vector_norm_L2[Inds_Exts]
Inds_non_exts<-which(vector_norm_L2<=v_threshd)
matplot(t(Data[Inds_Exts,]),type="l")

mtext(paste0("Extreme obs conserved (",name_variable,")"))
Exts<-vector_pareto[Inds_Exts,]

Comp_angular<-t(t(Exts)%*%diag(Vect_L2_exts^(-1)))
matplot(t(Comp_angular),type="l")
mtext(paste0("Angular components (",name_variable,")"))
# ACP --------------------------------------------------
sd_time<-as.numeric(apply(X = Comp_angular,
                           MARGIN = 2,FUN = sd))
esp_time<-as.numeric(colMeans(Comp_angular))
Analyse<-FactoMineR::PCA(X =Comp_angular,
                         scale.unit = std_data,
                         ncp = NB_dim_ACP)

```

We keep the first $J$ eigenvectors. Thus, we reduce the problem dimension as we only approach the law of the first two coordinates.
```{r}
val_lambda<-Analyse$eig[,1]
vect_diff<-cumsum(c(0,val_lambda))/sum(val_lambda)
vector_propvarexp<-1-vect_diff
L<-length(vector_propvarexp)-1
plot(c(0:L),vector_propvarexp,
     type="o",ylab="Proportion of unexplained inertia", 
     xlab="Number of eigenvectors",
     cex.lab=1.5)
par(mfrow=c(1,2))
Coord1<-Analyse$ind$coord[,1]
Coord2<-Analyse$ind$coord[,2]
F_eigen<-Analyse$svd$V
plot(Coord1,Coord2)
Coordinates<-Analyse$ind$coord[,1:NB_dim_ACP]
write.csv(file=paste0("residuals/ACP_results/Theta_coords_ACP_",name_variable,".csv"),x=Coordinates)
dataUnif<-pobs(Coordinates)
```

### Copula theory to approach the law of coordinates
```{r}

# Simulation_norm --------------------------------------------------------
values_unif<-runif(M)
reals_P_std<-sapply(values_unif,Generation_Pareto_std)
COEFF<-reals_P_std*v_threshd

if(NB_dim_ACP==2){
  Family_chosen<-BiCopSelect(dataUnif[,1],dataUnif[,2])
  Realisations_copules<-BiCopSim(N=M,family =Family_chosen$family,par = Family_chosen$par,par2 =Family_chosen$par2,check.pars = TRUE)
  Summary_cop<-summary(Family_chosen)
  
  Short_famille_name<-BiCopName(family = Summary_cop[["family"]],short=TRUE)
  elt<-c(Summary_cop[["familyname"]],Summary_cop[["par"]],Summary_cop[["par2"]],Summary_cop[["tau"]],Summary_cop[["beta"]],unlist(Summary_cop[["taildep"]]))
  L<-length(elt)
  elt<-as.data.frame(t(elt))
  colnames(elt)<-c("Nom","par","par2","tau","beta","ltd","uptd")
  elt[,c("par","par2","tau","beta","ltd","uptd")]<-round(as.numeric(elt[,c("par","par2","tau","beta","ltd","uptd")]),1)
  write.csv(elt,file = paste0("residuals/",name_variable,"_coords_UV_copules.csv"),
           row.names = FALSE)
}else{
matrix_C<-function_Structure_Matrix(NB_dim = NB_dim_ACP)
Family_chosen<-VineCopula::RVineCopSelect(dataUnif[,c(1:NB_dim_ACP)],
                                            Matrix = matrix_C)
Code_utilisee<-summary(Family_chosen)$family
write.csv(x = Code_utilisee,
          file = paste0("residuals/ACP_results/",name_variable,"_modele_Vine.txt"))
Realisations_copules<-VineCopula::RVineSim(N=M,RVM = Family_chosen) 
obj_family<-summary(Family_chosen)
obj_family$par<-ifelse(obj_family$cop=="I",NA,obj_family$par)
obj_family$par2<-ifelse(obj_family$cop=="I",NA,obj_family$par2)
obj_family$utd<-ifelse(obj_family$cop %in% c("I","BB8_90","Tawn2_90","BB8","J270","J90","F"),NA,
                        obj_family$utd)
obj_family$ltd<-ifelse(obj_family$cop %in% c("I","BB8_90","Tawn2_90","BB8","J270","J90","F","Tawn","J","Tawn2","SC"),NA,
                        obj_family$ltd)
obj_family$family<-BiCopName(obj_family$family,short = FALSE)
dim_variable<-ncol(obj_family)
obj_family<-obj_family[,c(1:3,5:dim_variable)]
colnames(obj_family)[c(1:3)]<-c("arbre","couples-cond","nom-copule")
obj_family[,c("par","par2","tau","utd","ltd")]<-round(obj_family[,c("par","par2","tau","utd","ltd")],1)
write.csv(obj_family,file = paste0("residuals/",name_variable,"_coords_UV_copules.csv"))
}
  
```

```{r}
par(mfrow=c(1,2))
plot(dataUnif[,1],dataUnif[,2],xlab="Première coordonnée (observations)",ylab="Seconde coordonnée (observations)")
plot(Realisations_copules[,1],Realisations_copules[,2],col="red",xlab="Première coordonnée",ylab="Seconde coordonnée")
title(paste0("Comparaison entre les observations et les simulations pour ", name_variable),outer = TRUE,line=-3)
# Conversion dans la bonne échelle ----------------------------------------
matrix_coords_ALL<-matrix(NA,ncol = NB_dim_ACP,nrow = M)
for(l in c(1:NB_dim_ACP)){
  matrix_coords_ALL[,l]<-quantile(Coordinates[,l],probs=Realisations_copules[,l])
}
if(std_data==TRUE){
  Shape_ACP<-function_reconstitution_trajectory_std(Vector_coords = matrix_coords_ALL,Base_functions_p = F_eigen,
  NB_dim =NB_dim_ACP,mu_t = esp_time,sd_t = sd_time)
}else{
  Shape_ACP<-fonction_reconstitution_trajectoire(vector_coords =   matrix_coords_ALL,Base_fonctions_p = F_eigen,NB_dim = NB_dim_ACP,mu_t = esp_time)
}
L2_proche_1<-apply(X =Shape_ACP,MARGIN = 1,FUN = calcul_norm_L2)
Shape_ACP<-t(t(Shape_ACP)%*%diag(L2_proche_1^(-1)))

New_obs_P_acp<-t(t(Shape_ACP)%*%diag(COEFF))
threshd_marg<-log(10^5)^(-1)
indicator_pos<-which(apply(X=New_obs_P_acp-threshd_marg,
                               FUN=fonction_trajectoire_positive,MARGIN = 1)==TRUE)
New_obs_P_acp<-New_obs_P_acp[indicator_pos,]
f_copy<-Shape_ACP[indicator_pos,]
Gap<-M-length(indicator_pos)
Shape_for_analyse<-f_copy
coord_for_analyse<-matrix_coords_ALL[indicator_pos,]
```

As we are able to approach the law of angle with the PCA, we now use the results in regular variations to simulate extreme time series with heavy-tail margins. 

#(II) Simulation of extreme time series

##(1) Simulate new angles
```{r}
while (Gap!=0){
  if(NB_dim_ACP==2){
    Real_copules<-BiCopSim(N=Gap,family =Family_chosen$family,par = Family_chosen$par,par2 =Family_chosen$par2,check.pars = TRUE)
  }
  else{
    Real_copules<-VineCopula::RVineSim(N=Gap,RVM = Family_chosen)
  }
  matrix_coords_Gap<-matrix(NA,ncol = NB_dim_ACP,nrow = Gap)
  for(l in c(1:NB_dim_ACP)){
    if(Gap==1){
      matrix_coords_Gap[,l]<-quantile(Coordinates[,l],probs=Real_copules[,l])
    }
    else{
      matrix_coords_Gap[,l]<-quantile(Coordinates[,l],probs=Real_copules[l])
    }
  }
  Shape_Gap<-function_reconstitution_trajectory_std(Vector_coords = matrix_coords_Gap,Base_functions_p  = F_eigen,NB_dim = NB_dim_ACP,mu_t =esp_time,sd_t = sd_time)
  
  L2_Gap<-apply(X =Shape_Gap,MARGIN = 1,FUN = calcul_norm_L2)
  Shape_Gap<-t(t(Shape_Gap)%*%diag(L2_Gap^(-1)))
  
  values_unif_e<-runif(Gap)
  reals_P_Gap<-sapply(values_unif_e,Generation_Pareto_std)
  COEFF_Gap<-reals_P_Gap*v_threshd
  
  New_obs_Gap<-t(t(Shape_Gap)%*%diag(COEFF_Gap))
  indicator_pos<-which(apply(X=New_obs_Gap-threshd_marg,FUN=fonction_trajectoire_positive,MARGIN = 1)==TRUE)
  if(length(indicator_pos)!=0){
    f_copy<-Shape_Gap[indicator_pos,]
    Shape_for_analyse<-rbind(Shape_for_analyse,f_copy)
    coord_for_analyse<-rbind(coord_for_analyse,
                            matrix_coords_Gap[indicator_pos,])
    New_obs_P_acp<-rbind(New_obs_P_acp,
                               New_obs_Gap[indicator_pos,])
    Gap<-Gap-length(indicator_pos)
  }
  
}
L2_realisations<-apply(X = New_obs_P_acp,MARGIN = 1,FUN = calcul_norm_L2)
indexes_ACP<-1:nrow(New_obs_P_acp)
Angle_realisations<-t(t(New_obs_P_acp)%*%diag(L2_realisations^(-1)))
write.csv(x = New_obs_P_acp,
          file=paste0("residuals/Pareto/",name_variable,"_simul_Pareto.csv"))

```

```{r}
# Comparing_Coordinates -------------------------------------------------
write.csv(x=vector_pareto,file=paste0("residuals/Pareto/",name_variable,"_obs_ech_Pareto.csv"))
Min_y<-min(c(apply(Shape_for_analyse,MARGIN = 2,FUN = min),
             apply(Comp_angular,MARGIN = 2,FUN = min)))
Max_y<-max(c(apply(Shape_for_analyse,MARGIN = 2,FUN = max),
             apply(Comp_angular,MARGIN = 2,FUN = max)))
Time<-(c(1:37)-19)*(1/6)
xlab_chosen<-"Time (hour) with respect to tidal peak"
matplot(Time,t(Comp_angular),type="l",ylim=c(Min_y,Max_y),xlab=" ",
        ylab="value (-)",cex.lab=1.5)
matplot(Time,t(Shape_for_analyse),type="l",ylim=c(Min_y,Max_y), 
        xlab=NA,ylab=NA,cex.lab=1.5)
nom_graph<-ifelse(name_variable=="Surcote","S",
                  name_variable)
mtext(xlab_chosen, side = 3, line = -22, outer = TRUE,
      cex=1.5)
# Work on the norm -----------------------------------------------------------
norm_theta_simul<-apply(X = Shape_for_analyse,MARGIN = 1,
                         FUN = calcul_norm_L2)
```


```{r}
par(mfrow=c(1,1))
plot(density(norm_theta_simul),
     main=expression(paste0("Density of the L2 norm of ",theta," simulated")))
abline(v=1,col="red")
write.csv(file=paste0("residuals/ACP_results/Theta_Vine_simul_",name_variable,".csv"),x=coord_for_analyse)
write.csv(file=paste0("residuals/ACP_results/evolution_eigen_value_",name_variable,".csv"),x=val_lambda)
```


```{r}
if(std_data==TRUE){
    Angle_realisations_std<-scale(Angle_realisations,center = esp_time,
                                  scale = sd_time)
    Conversion_realisations<-Angle_realisations_std%*%F_eigen[,c(1:NB_dim_ACP)]
}else{
  Conversion_realisations<-Angle_realisations%*%F_eigen[,c(1:NB_dim_ACP)]
  
}
matrix_test_nulles<-matrix(nrow=2,ncol=2*NB_dim_ACP)
Z<-1
for(j in c(1:NB_dim_ACP)){
  KS_j<-ks.test(x = Conversion_realisations[,j],
                y=Coordinates[,j])$p.value
  MW_j<-wilcox.test(x = Conversion_realisations[,j],
                    y=Coordinates[,j])$p.value
  matrix_test_nulles[,Z]<-c(KS_j,MW_j)
  Z<-Z+1
}

# Export coords pour scale Pareto ---------------------------------------
write.csv(file=paste0("residuals/ACP_results/",name_variable,"_coords_obs.csv"),x=Coordinates)
write.csv(file=paste0("residuals/ACP_results/",name_variable,"_coords_simul.csv"),x=Conversion_realisations)
Pre_transf<-New_obs_P_acp
if(opt_Frech==TRUE){
  Unif<-exp((-1)*New_obs_P_acp^(-1))
  New_obs_P_acp<-(1-Unif)^(-1)
}

```
## 2) Applying the reverse marginal transformation
```{r}
NO_ACP<-lapply(indexes_ACP,FUN = fnct_select_colonne,df=New_obs_P_acp)

# Reconversion in the correct scale. --------------------------------------
Variables_reconversion_ACP<-parLapply(cl =CPU_hearts,NO_ACP,function_reconversion_Pareto,K=K,list_evt=L_EVT)
Variables_reconversion_ACP<-do.call(rbind.data.frame,
                                    Variables_reconversion_ACP)

colnames(Variables_reconversion_ACP)<-1:ncol(Variables_reconversion_ACP)
# 
# Coordinates initial scale--------------------------------------------
L2_X<-apply(X = Data[Inds_Exts,],FUN=calcul_norm_L2,MARGIN=1)
Comp_ANG_X<-t(t(Data[Inds_Exts,])%*%diag(L2_X^(-1)))
PCA_X<-PCA(X =Comp_ANG_X,scale.unit =std_data,ncp =NB_dim_ACP,graph = FALSE)
Coords_data_X<-PCA_X$ind$coord[,c(1:NB_dim_ACP)]

L2_realisations<-apply(X=Variables_reconversion_ACP,FUN=calcul_norm_L2,MARGIN=1)
Comp_ANG_Xsimul<-t(t(Variables_reconversion_ACP)%*%diag(L2_realisations^(-1)))
if(std_data==TRUE){
  sdX_time<-apply(X = Comp_ANG_X,MARGIN = 2,FUN = sd)
  espX_time<-colMeans(Comp_ANG_X)
  Comp_ANG_Xsimul<-scale(Comp_ANG_Xsimul,center = espX_time,scale = sdX_time)
}
Coords_simul_X<-Comp_ANG_Xsimul%*%(PCA_X$svd$V[,c(1:NB_dim_ACP)])
for(z in c(1:NB_dim_ACP)){
  KS_j<-ks.test(x = Coords_simul_X[,z],y=Coords_data_X[,z])$p.value
  MW_j<-wilcox.test(x = Coords_simul_X[,z],y=Coords_data_X[,z])$p.value
  matrix_test_nulles[,Z]<-c(KS_j,MW_j)
  Z<-Z+1
}

```

```{r}
# Export of resid simulations --------------------------------------------
Std<-ifelse(std_data,"with_std","without_std")
write.csv(file=paste0("residuals/Simulations_",name_variable,"_",Std,".csv"),x = Variables_reconversion_ACP)
# Downloading indexes of extreme individuals-------------
Data_ext<-Data[Inds_Exts,]
Inds_Exts_mat<-cbind(Inds_Exts,c(1:length(Inds_Exts)))
write.csv(Inds_Exts_mat,file = paste0("residuals/inds_extremes_data_",name_variable,".csv"))
Transf_for_return<-as.data.frame(Angle_realisations)
colnames(Transf_for_return)<-c(1:ncol(Transf_for_return))
```

## End of the code
```{r}
stopCluster(CPU_hearts)
```

